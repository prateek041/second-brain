# What is DNS

DNS is an abstraction that allows us to give addresses short names, i.e. convert IP addresses to words, that people can remember.
## Dig
Test out how `dig` command works.

### A record
A record stands for **Address Record** which is a DNS record that maps a domain name directly to the numerical IP address.

#### Components
There are three main components
- **Domain name**: Website address in words (human readable). e.g. www.example.com.
- **IP Address**: The IPv4 address where the domain is hosted.
- **TTL (Time to LIve)**: The duration for which this record is cached on the DNS server.
```bash
dig google.com

; <<>> DiG 9.18.24 <<>> google.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 41844
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;google.com.                    IN      A

;; ANSWER SECTION:
google.com.             52      IN      A       142.250.183.174

;; Query time: 61 msec
;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)
;; WHEN: Tue Apr 23 23:57:44 IST 2024
;; MSG SIZE  rcvd: 55
```

in the above command where I am using Dig, the A record looks like `example.com(Domain name) 3600(TTL) IN(Class, which internet) A(type of record) 192.0.2.123(IP address)`

## /etc/resolv.conf
Here is an explanation of this file in simple words. This file tells the computer where it should look for when trying to find out the IP addresses associated with the domain names.

- **`nameserver 127.0.0.53`**: This line tells the computer, "For DNS Lookups, ask the local service running at IP address 127.0.0.53".
	- Why local service ?
		- It is a local server provided by `systemd-resolved`. This server acts as a middle man, which stores the answers of DNS queries to speed up future requests.
		- It also handles communication with real DNS servers running on the internet.
- **`options edns0 trust-ad`**: These are additional options which have their own use.
	- **`edns0`** This tells the local resolver to use a newer standard of DNS called EDNS, which has technical improvements that enables to do things like handling larger DNS messages.
	- **`trust-ad`**: this is about security settings which we will look later on.
- **`search .`**: It tells how to fully qualify the incomplete domain names. more examples later on.

Let's talk more about Search:
#### Search
this keyword in the resolv.conf contains a list of domain names that will be added to any unqualified hostnames.

> Unqualified hostnames are those without a "dot"
> This is used quite often in environments with short, local hostnames.

So, if the `resolv.conf` file contains `example.com` as the search field. when any unqualified hostnames, like `webserver` is searched, it will be auto-completed to `webserver.example.com`.

If the results are still not found, then the DNS resolver might just attempt to resolve `webserver`.



### what really happens ?
When any application on your computer want's to lookup IP address for a website, it checks the local cache first, so for systemd supported systems, the request goes to `systemd-resolved`. where this server then handles the entire process of resolving the domain name, if IP is present in the cache, it returns the IP, else it forwards the request to DNS resolver on the internet to eventually get a response and cache it.

## Inside docker
now, when I do `/etc/resolv.conf` inside my docker, I see some different things, why ?

when docker starts a container, it forms the resolve.conf based on the host machine, with some alterations. Also, it does not use the `systemd-resolved` address for DNS lookup, instead it bypasses it to closes `actual DNS server`.

Actual DNS server here means not something running locally, but something like you routers, ISP DNS servers etc.

```bash

bash-5.2# cat /etc/resolv.conf
# Generated by Docker Engine.
# This file can be edited; Docker Engine will not make further changes once it
# has been modified.

nameserver 192.168.1.1
search .

# Based on host file: '/run/systemd/resolve/resolv.conf' (legacy)
# Overrides: []

```

here, the `nameserver` is `192.168.1.1`, which is the actual DNS server being used by the `systemd-resolved` daemon.

> Note: The IP address of the actual DNS server can be seen using `resolvectl status`.

output of `resolvectl status` is same as the `nameserver` being used by the docker container.

```bash
➜  ~ resolvectl status
Global
         Protocols: LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub

Link 2 (enp2s0)
    Current Scopes: none
         Protocols: -DefaultRoute LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupported

Link 3 (wlo1)
    Current Scopes: DNS LLMNR/IPv4 LLMNR/IPv6
         Protocols: +DefaultRoute LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: fe80::1
       DNS Servers: 192.168.1.1 fe80::1

Link 4 (docker0)
    Current Scopes: LLMNR/IPv4 LLMNR/IPv6
         Protocols: -DefaultRoute LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupported

Link 18 (veth0d7cf6c)
    Current Scopes: LLMNR/IPv6
         Protocols: -DefaultRoute LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupported

Link 22 (veth709bb0e)
    Current Scopes: LLMNR/IPv6
         Protocols: -DefaultRoute LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupported

```
CName record (canonical name): Allows to map one host name to another.

> dns.squish.net


https://platform.openai.com/playground?assistant=asst_HCVkwRp9sQPE99dfUnWBCkbF&mode=assistant&thread=thread_OtngcX2asiR9yC9APKQrRpOe
### Libc vs muscl
Alpine uses muscl instead of Glibc

muscl always made queries but glibc cached the results

glibc will only match search domain names until one matches, but musl will match all of them.

### Docker vs Kubernetes resolve conf file

**Docker**

```bash
bash-5.2# cat /etc/resolv.conf
# Generated by Docker Engine.
# This file can be edited; Docker Engine will not make further changes once it
# has been modified.

nameserver 192.168.1.1
search .

# Based on host file: '/run/systemd/resolve/resolv.conf' (legacy)
# Overrides: []

```

**Kubernetes**
```bash
bash-5.2# cat /etc/resolv.conf
search default.svc.cluster.local svc.cluster.local cluster.local
nameserver 10.96.0.10
options ndots:5
```

**local machine**
```bash
 ~ cat /etc/resolv.conf
# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8).
# Do not edit.
#
# This file might be symlinked as /etc/resolv.conf. If you're looking at
# /etc/resolv.conf and seeing this text, you have followed the symlink.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs should typically not access this file directly, but only
# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a
# different way, replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.

nameserver 127.0.0.53
options edns0 trust-ad
search .

```

### Kubernetes

Here the coreDNS is caching but with a little bit more agressive approach, i.e. deleting records in 30 seconds.

Every service inside the same namespace can talk to each other using unqualified domain names.

#### Kubectl expose

Service resource routes the traffic to the selected resource (pod, deployment etc.). This service acts as an abstraction layer over the pods, so that even if the pods get destroyed, or scaled (up/down) they are still accessible through the same interface (IP address or URL).

There are many types of Services:
- ClusterIP
- NodePort
- LoadBalancer

to create a service, the `kubectl expose` command can be used that has the following labels

`kubectl expose <type> <name> --port=<port>`
- type : deployment, pod, replica set etc.
- name: name of the resource.
- port: the port that the service will be exposed at (listening to).
- target-port: container port, that the service will route traffic to.
- type: ClusterIP, LoadBalancer or NodePort.

#### Example
So, if we create a deployment named echo, using the command
`kubectl create deployment echo --image=inanimate/echo-server`
It will create a deployment with some labels.
```yaml
Name:                   echo
Namespace:              default
CreationTimestamp:      Wed, 24 Apr 2024 14:57:14 +0530
Labels:                 app=echo
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=echo
Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=echo
  Containers:
   echo-server:
    Image:         inanimate/echo-server
    Port:          <none>
    Host Port:     <none>
    Environment:   <none>
    Mounts:        <none>
  Volumes:         <none>
  Node-Selectors:  <none>
  Tolerations:     <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   echo-7d8c7864f7 (1/1 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  22m   deployment-controller  Scaled up replica set echo-7d8c7864f7 to 1
```


then, if we create a service for it using the command
`kubectl expose deployment echo --port=8080`.

It will create a `service` looking like this

```yaml
Name:              echo
Namespace:         default
Labels:            app=echo
Annotations:       <none>
Selector:          app=echo
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
IP:                10.96.204.48
IPs:               10.96.204.48
Port:              <unset>  8080/TCP
TargetPort:        8080/TCP
Endpoints:         10.244.0.6:8080
Session Affinity:  None
Events:            <none>
```

Now where does this `Endpoints` come from ? When a service is created using the expose command, Kubernetes assigns an IP where the service is accessible dynamically. but where does that service expose traffic to ? to the endpoints. The value of endpoint is extracted from pods that match the selector labels. So, any pod in the default namespace having label `app=echo` will be selected, then it's pod IP is used as the endpoint. and the port which you provide in the command itself will be the port present in the Endpoints.

> Note: Kubectl expose command looks for the resource type to expose (pod, deployment etc.) within the current namespace context.

### Workflow Explanation:

1. **You run:** `kubectl expose deployment echo --port=8080`
2. **Namespace Context:** Suppose your current context is set to the `default` namespace.
3. **Action:**
    - Kubernetes looks for a deployment named `echo` in the `default` namespace.
    - It identifies the pods created by this deployment based on the deployment's selector (`app=echo`).
    - It creates a service that routes traffic to these pods, using their cluster IPs as endpoints, at the specified service `--port=8080`.
    - If the pods are listening on the same port, `--target-port` need not be specified. Otherwise, `--target-port` should match the listening port of the applications running inside the pods.

## NSS Switch /etc/nssswitch
## Gai /etc/gai.conf


